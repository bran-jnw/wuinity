#pragma kernel Initialize
#pragma kernel Inject
#pragma kernel ManualInject
#pragma kernel Transport

#define THREAD_COUNT 64

#include "Particle.cginc"
#include "Random.cginc"
#include "MoninObukhov.cginc"

uniform float4 _wind;
uniform float deltaTime, particleMass, sizeX, sizeY;
uniform float randomX, randomY, randomZ;
uniform uint _particleCount, _particlesLeft;
uniform uint _cellsX, _cellsY;


RWStructuredBuffer<Particle> particleBuffer;
ConsumeStructuredBuffer<uint> particlePool;
AppendStructuredBuffer<uint> deadParticles;
uniform StructuredBuffer<float> sootInjection;


[numthreads(THREAD_COUNT, 1, 1)]
void Initialize(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _particleCount)
    {
        return;
    }
    
    particleBuffer[id.x].pos = float4(0, 0, 0, 0);
    particleBuffer[id.x].vel_turbulent = float3(0, 0, 0);        
    //this is filling the particle pool on the cpu side
    deadParticles.Append(id.x);      
}

[numthreads(8, 8, 1)]
void Inject(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _cellsX || id.y >= _cellsY)
    {        
        return;
    }
    
    uint idx = id.x + id.y *_cellsX;
    if (idx > _particlesLeft)
    {
        if (sootInjection[idx] > 0.0)
        {
            int numberOfParticles = (int) (0.5 + sootInjection[idx] / particleMass);
            for (int i = 0; i < numberOfParticles; ++i)
            {
                //take an index from the available particles
                uint particleId = particlePool.Consume();
                //activate particle
                particleBuffer[particleId].pos = float4(id.x * sizeX, id.y * sizeY, 0, 1);
            }
        }
    }         
}

uniform uint _particleInjectionCount;
[numthreads(THREAD_COUNT, 1, 1)]
void ManualInject(uint3 id : SV_DispatchThreadID)
{ 
    if (id.x < _particleInjectionCount)
    {
        //take an index from the available particles
        uint particleId = particlePool.Consume();               
        particleBuffer[particleId].pos.x = 0;
        particleBuffer[particleId].pos.y = 0;
        particleBuffer[particleId].pos.z = 0;
        //activate particle
        particleBuffer[particleId].pos.a = 1.0;
    }         
}

float get_R(float TL_i)
{
    return exp(-deltaTime / TL_i);
}

float get_sigma_w(float K_w, float TL_w)
{
    return sqrt(K_w / TL_w);
}

float get_sigma_u(float sigma_w)
{
    return 0.25 * sigma_w;
}

uniform float TL_u = 10800.0;
uniform float TL_w = 200.0;
uniform float K_xy = 100.0;
uniform float mixing_layer_height = 500.0;

[numthreads(THREAD_COUNT, 1, 1)]
void Transport(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _particleCount)
    {
        return;
    }
    
    //read data from buffer
    Particle p = particleBuffer[id.x];    
    if (p.pos.a > 0)
    {
        
        //first guess position, use when we have grid data for wind
        //float3 initial_pos = p.pos;
        //float3 temp_pos = _wind(initial_pos) * deltaTime;
        //p.pos = initial_pos + 0.5 * (_wind(p.pos) + _wind(temp_pos)) * deltaTime;
        
        /*float R_uv = get_R(TL_u);
        float R_uv_squared = R_uv * R_uv;
        float R_w = get_R(TL_w);
        float lambda_x = RandomGaussian(id.x + CPU_SEED.x);
        float lambda_y = RandomGaussian(id.x + CPU_SEED.y);
        float lambda_z = RandomGaussian(id.x + CPU_SEED.z);
        float sigma_w = get_sigma_w(1.0, 1.0);
        float sigma_u = get_sigma_u(sigma_w);
        
        float U_prim = R_uv * p.vel_turbulent.x + sigma_u * lambda_x + sqrt(1.0 - R_uv_squared);
        float V_prim = R_uv * p.vel_turbulent.y + sigma_u * lambda_y + sqrt(1.0 - R_uv_squared);
        
        //vertical gradient is d_sigma_w / d_z
        float vertical_gradient = 1.0;
        float sigma_w_tdt = sigma_w + p.vel_turbulent.z * deltaTime * vertical_gradient;
        float W_prim_sigma_w = R_w * (p.vel_turbulent.z / sigma_w) + lambda_z + sqrt(1.0 - R_w * R_w) + TL_w * (1.0 - R_w) * vertical_gradient;
        float W_prim = W_prim_sigma_w * sigma_w_tdt;        
        
        //add advective velocity to turbulent velocity
        float3 velocity = _wind.xyz + U_prim + V_prim + W_prim;     
        //move the particle
        p.pos += velocity * deltaTime;        
        
        //save current turbulent velocity
        p.vel_turbulent.x = U_prim;
        p.vel_turbulent.y = V_prim;
        p.vel_turbulent.z = W_prim;      */  
        
        float3 velocity = _wind.xyz;
        //move the particle
        p.pos.x += velocity.x * deltaTime;
        p.pos.z += velocity.z * deltaTime;
        
        //if done/hit ground?
        if (p.pos.y <= 0.0)
        {
            //p.active = false;
            //deadParticles.Append(id.x);
        }        
        
        //write changes data back to buffer
        particleBuffer[id.x] = p;
    }
}
